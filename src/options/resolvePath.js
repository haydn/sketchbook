// @flow
import type { Option } from "../types/types";

/**
 * Recurses through the object generated by reconcilePath
 * based on the path supplied. There is an arbitrary maximum
 * depth of recursion of 10 iterations.
 *
 * Only record and list options need to be recursed over as only
 * they can be nested deeply.
 */
const resolvePath = ({
  path,
  options
}: {
  path: Array<string | number>,
  options: Option
}): { options: Option } => {
  const MAX_DEPTH = 10;
  // We subtract 1 because we don't include the root in the path when calling this function.
  if (path.length >= MAX_DEPTH - 1) {
    throw Error(
      `You cannot traverse more than ${MAX_DEPTH} layers deep! Please reduce the amount of nesting in your document.`
    );
  }

  if (path.length > 0) {
    if (options.type === "Record") {
      const nextField = options.fields.find(field => {
        const nextPath = field.value.path;
        const nextPathItem = nextPath[nextPath.length - 1];

        return nextPathItem === path[0];
      });

      if (nextField === undefined) {
        throw Error(
          `Cannot find a record that matches path: ${path.join(".")}`
        );
      }

      const nextOption = nextField.value;

      return resolvePath({
        path: path.slice(1),
        options: nextOption
      });
    }

    if (options.type === "List") {
      // options.value.items when going from list to list
      // otherwise, option.items
      const listItems = options.items || options.value.items;
      const nextOption = listItems.find(item => {
        const nextPath = item.path;
        const nextPathItem = nextPath[nextPath.length - 1];

        return nextPathItem === path[0];
      });

      if (nextOption === undefined) {
        throw Error(
          `Cannot find a list item that matches path: ${path.join(".")}`
        );
      }

      return resolvePath({
        path: path.slice(1),
        options: nextOption
      });
    }

    throw Error("Can't resolve path.");
  }

  return { options };
};

export default resolvePath;
